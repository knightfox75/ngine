<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentación n'gine - NGN_IMAGE</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>NGN_IMAGE.H</h1>
        </header>

        <main>
            <!-- ÍNDICE DE MÉTODOS -->
            <h2>MÉTODOS de la clase</h2>
            <nav class="index">
                <ul>
                    <li><a href="#ConvertRawToTextureData">ConvertRawToTextureData</a></li>
                    <li><a href="#CutOutMask">CutOutMask</a></li>
                    <li><a href="#HollowMask">HollowMask</a></li>
                    <li><a href="#AdvancedMask">AdvancedMask</a></li>
                    <li><a href="#RendererToSurface">RendererToSurface</a></li>
                    <li><a href="#SurfaceToRaw">SurfaceToRaw</a></li>
                </ul>
            </nav>
            <hr>

            <!-- BLOQUES DE DOCUMENTACIÓN DE MÉTODOS -->
            <section id="ConvertRawToTextureData" class="doc-block">
                <h3>Método</h3>
                <pre><code>NGN_TextureData* ConvertRawToTextureData(NGN_RawImage* raw);</code></pre>
                <h3>Descripción</h3>
                <p>Convierte una imagen en formato RAW a datos de textura. Devuelve NULL en caso de error.</p>
                <h3>Ejemplo</h3>
                <pre><code>NGN_RawImage* pixels = ngn->load->SpriteAsRaw("data/coin.spr", 3);
NGN_TextureData* coin_data = ngn->image->ConvertRawToTextureData(pixels);</code></pre>
            </section>

            <section id="CutOutMask" class="doc-block">
                <h3>Método</h3>
                <pre><code>bool CutOutMask(
    NGN_RawImage* source,       // Imagen RAW de origen
    NGN_RawImage* mask,         // Imagen RAW de mascara
    NGN_RawImage* destination   // Imagen RAW de destino
);</code></pre>
                <h3>Descripción</h3>
                <p>Aplica la máscara de recorte especificada a la imagen de origen y almacena el resultado en la imagen de destino. Si los pixeles de la máscara contienen información de transparencia (canal alpha), esta también se aplica. Devuelve TRUE en caso de éxito y FALSE en caso de error.</p>
                <h3>Ejemplo</h3>
                <pre><code>NGN_RawImage* stone = ngn->load->PngAsRaw("data/stone.png");
NGN_RawImage* mask = ngn->load->PngAsRaw("data/cutmask.png");
NGN_RawImage* pixels = new NGN_RawImage();
ngn->image->CutOutMask(stone, mask, pixels);</code></pre>
            </section>

            <section id="HollowMask" class="doc-block">
                <h3>Método</h3>
                <pre><code>bool HollowMask(
    NGN_RawImage* source,       // Imagen RAW de origen
    NGN_RawImage* mask,         // Imagen RAW de mascara
    NGN_RawImage* destination   // Imagen RAW de destino
);</code></pre>
                <h3>Descripción</h3>
                <p>Aplica la máscara de vaciado especificada a la imagen de origen y almacena el resultado en la imagen de destino. Si los pixeles de la máscara contienen información de transparencia (canal alpha), esta también se aplica. Devuelve TRUE en caso de éxito y FALSE en caso de error.</p>
                <h3>Ejemplo</h3>
                <pre><code>NGN_RawImage* stone = ngn->load->PngAsRaw("data/stone.png");
NGN_RawImage* mask = ngn->load->PngAsRaw("data/cutmask.png");
NGN_RawImage* pixels = new NGN_RawImage();
ngn->image->HollowMask(stone, mask, pixels);</code></pre>
            </section>

            <section id="AdvancedMask" class="doc-block">
                <h3>Método</h3>
                <pre><code>bool AdvancedMask(
    NGN_RawImage* source,                   // Imagen de origen
    NGN_RawImage* mask,                     // Imagen de la máscara
    NGN_RawImage* destination,              // Imagen de destino
    Vector2I32 offset = {0, 0},             // Offset de la máscara
    uint8_t mode = NGN_MASKMODE_CUTOUT      // Modo de la máscara
);</code></pre>
                <h3>Descripción</h3>
                <p>Aplica la máscara especificada a la imagen de origen y almacena el resultado en la imagen de destino. Si los pixeles de la máscara contienen información de transparencia (canal alpha), esta también se aplica. Puede especificarse el modo de aplicación de la máscara, <code>NGN_MASKMODE_CUTOUT</code> o <code>NGN_MASKMODE_HOLLOW</code> (recorte o vaciado), así como el desplazamiento de la máscara (offset). Devuelve TRUE en caso de éxito y FALSE en caso de error.</p>
                <h3>Ejemplo</h3>
                <pre><code>NGN_RawImage* stone = ngn->load->PngAsRaw("data/stone.png");
NGN_RawImage* mask = ngn->load->PngAsRaw("data/cutmask.png");
NGN_RawImage* pixels = new NGN_RawImage();
Vector2I32 offset = {15, 25};
ngn->image->AdvancedMask(stone, mask, pixels, offset, NGN_MASKMODE_CUTOUT);</code></pre>
            </section>

            <section id="RendererToSurface" class="doc-block">
                <h3>Método</h3>
                <pre><code>bool RendererToSurface(NGN_RendererSurface* destination);</code></pre>
                <h3>Descripción</h3>
                <p>Guarda el contenido actual del renderer en el objeto tipo NGN_RendererSurface especificado. Devuelve TRUE en caso de existo o FALSE en caso de error.</p>
                <h3>Ejemplo</h3>
                <pre><code>RendererSurface* renderer_surface = new NGN_RendererSurface();
ngn->image->RendererToSurface(renderer_surface);</code></pre>
            </section>

            <section id="SurfaceToRaw" class="doc-block">
                <h3>Método</h3>
                <pre><code>bool SurfaceToRaw(
    NGN_RendererSurface* source,    // Surface de origen
    NGN_RawImage* destination,      // Imagen RAW de destino
    NGN_RawImage* mask = NULL       // Mascara cutout (opcional)
);</code></pre>
                <h3>Descripción</h3>
                <p>Convierte el Surface especificado a una imagen en formato RAW y, opcionalmente, le aplica una máscara de recorte si esta se especifica. Este método devuelve TRUE en caso de éxito o FALSE en caso de error.</p>
                <h3>Ejemplo</h3>
                <pre><code>RendererSurface* renderer_surface = new NGN_RendererSurface();
ngn->image->RendererToSurface(renderer_surface);
NGN_RawImage* mask = ngn->load->PngAsRaw("data/cutmask.png");
NGN_RawImage* pixels = new NGN_RawImage();
ngn->image->SurfaceToRaw(renderer_surface, pixels, mask);</code></pre>
            </section>
        </main>
    </div>

	<!-- BOTONES FLOTANTES Y SCRIPT (con menú desplegable para el Manual) -->
	<div class="floating-buttons">
        <!-- Bandeja de botones que se mostrará/ocultará -->
		<div id="button-tray">
			<a href="index.html">Volver al Índice</a>
			<!-- Enlace a la página equivalente en inglés -->
			<a href="../en/ngn_image.html">English Version</a>
			<a href="#" id="back-to-top">Volver Arriba</a>
		</div>
        <!-- Botón principal que siempre es visible en móvil -->
        <button id="menu-toggle">Menú ▲</button>
	</div>

    <script>
        // Lógica para el botón "Volver Arriba"
        const backToTopButton = document.getElementById('back-to-top');
        window.onscroll = () => {
            const scrollPosition = document.documentElement.scrollTop || document.body.scrollTop;
            if (scrollPosition > 200) { backToTopButton.classList.add('visible'); } 
            else { backToTopButton.classList.remove('visible'); }
        };
        
        // --- LÓGICA PARA EL MENÚ DESPLEGABLE ---
        const menuToggle = document.getElementById('menu-toggle');
        const floatingButtonsContainer = document.querySelector('.floating-buttons');
        menuToggle.addEventListener('click', () => {
            floatingButtonsContainer.classList.toggle('is-active');
        });

        floatingButtonsContainer.addEventListener('click', (e) => {
            if (e.target.id === 'back-to-top') {
                e.preventDefault();
                window.scrollTo({ top: 0, behavior: 'smooth' });
                floatingButtonsContainer.classList.remove('is-active');
            }
        });
    </script>
</body>
</html>