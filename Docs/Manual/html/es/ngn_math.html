<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentación n'gine - NGN_MATH</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>NGN_MATH.H</h1>
        </header>

        <main>
            <!-- MÉTODOS DE VECTOR2 -->
            <h2>MÉTODOS de la clase Vector2</h2>
            <div class="doc-block">
                <p>Esta clase incluye todos los métodos y propiedades necesarios para el uso básico de vectores en 2 dimensiones. Hay 3 variaciones de la clase, <code>Vector2</code>, <code>Vector2I32</code> y <code>Vector2I64</code>, con sus respectivas sobrecargas. Todas las clases tienen soporte para las operaciones de suma y resta entre vectores del mismo tipo, así como soporte para las operaciones de multiplicación y división entre un vector y un escalar, además de las operaciones lógicas de igualdad y diferencia.</p>
            </div>
            <nav class="index">
                <ul>
                    <li><a href="#Magnitude">Magnitude</a></li>
                    <li><a href="#Normalize">Normalize</a></li>
                    <li><a href="#Normal">Normal</a></li>
                    <li><a href="#Zero">Zero</a></li>
                </ul>
            </nav>
            <hr>

            <section id="Magnitude" class="doc-block">
                <h3>Método</h3>
                <pre><code>float Vector2.Magnitude() const;
int32_t Vector2I32.Magnitude() const;
int64_t Vector2I64.Magnitude() const;</code></pre>
                <h3>Descripción</h3>
                <p>Devuelve la magnitud del vector. En el caso de vectores de números enteros, devuelve el resultado más aproximado posible.</p>
                <h3>Ejemplo</h3>
                <pre><code>Vector2 my_vector = {10.0f, 25.0f};
float d = my_vector.Magnitude();</code></pre>
            </section>

            <section id="Normalize" class="doc-block">
                <h3>Método</h3>
                <pre><code>void Vector2.Normalize();</code></pre>
                <h3>Descripción</h3>
                <p>Este método solo está disponible en los vectores de punto flotante. Normaliza y actualiza el contenido del vector (convierte el contenido de las coordenadas X e Y a valores entre -1.0f y 1.0f).</p>
                <h3>Ejemplo</h3>
                <pre><code>Vector2 my_vector = {10.0f, 25.0f};
my_vector.Normalize();</code></pre>
            </section>

            <section id="Normal" class="doc-block">
                <h3>Método</h3>
                <pre><code>Vector2 Normal() const;</code></pre>
                <h3>Descripción</h3>
                <p>Este método solo está disponible en los vectores de punto flotante. Devuelve el valor normalizado del contenido de un vector, sin modificar el contenido del vector.</p>
                <h3>Ejemplo</h3>
                <pre><code>Vector2 my_vector = {10.0f, 25.0f};
Vector2 normal = my_vector.Normal();</code></pre>
            </section>
            
            <section id="Zero" class="doc-block">
                <h3>Método</h3>
                <pre><code>static Vector2 Zero();
static Vector2I32 Zero();
static Vector2I64 Zero();</code></pre>
                <h3>Descripción</h3>
                <p>Devuelve un vector donde todos sus componentes tienen un valor de cero.</p>
                <h3>Ejemplo</h3>
                <pre><code>Vector2 my_vector = Vector2::Zero();</code></pre>
            </section>
            <hr>

            <!-- PROPIEDADES DE VECTOR2 -->
            <h2>PROPIEDADES de la clase Vector2</h2>
            <section id="prop_xy" class="doc-block">
                <h3>Propiedad</h3>
                <pre><code>Vector2.x;
Vector2.y;</code></pre>
                <h3>Descripción</h3>
                <p>Propiedades principales del vector. Almacenan las coordenadas X e Y. Estas propiedades son del tipo del vector declarado (float, int32_t o int64_t).</p>
                <h3>Ejemplo</h3>
                <pre><code>Vector2 my_vector;
my_vector.x = 13.5f;
my_vector.y = 27.34f;</code></pre>
            </section>
            <hr>
            
            <!-- MÉTODOS DE NGN_MATH -->
            <h2>MÉTODOS de la clase NGN_Math</h2>
            <div class="doc-block">
                <p>Esta clase incluye funciones matemáticas básicas para ayudar al desarrollo de cualquier videojuego, como el cálculo de ángulos o distancias.</p>
            </div>
            <nav class="index">
                <ul>
                    <li><a href="#GetDistance">GetDistance</a></li>
                    <li><a href="#GetAngle">GetAngle</a></li>
                    <li><a href="#GetManhattan">GetManhattan</a></li>
                    <li><a href="#Random">RandomInt / RandomFloat / RandomDouble</a></li>
                    <li><a href="#Adler32Checksum">Adler32Checksum</a></li>
                </ul>
            </nav>
            <hr>

            <section id="GetDistance" class="doc-block">
                <h3>Método</h3>
                <pre><code>float GetDistance(float x1, float y1, float x2, float y2);
float GetDistance(Vector2 a, Vector2 b);
uint32_t GetDistance(int32_t x1, int32_t y1, int32_t x2, int32_t y2);
uint32_t GetDistance(Vector2I32 a, Vector2I32 b);</code></pre>
                <h3>Descripción</h3>
                <p>Devuelve la distancia entre 2 puntos (4 sobrecargas). En el caso de usar números enteros, se devuelve el valor más aproximado redondeado.</p>
                <h3>Ejemplo</h3>
                <pre><code>float d = ngn->math->GetDistance(100.0f, 100.0f, 200.0f, 300.0f);</code></pre>
            </section>
            
            <section id="GetAngle" class="doc-block">
                <h3>Método</h3>
                <pre><code>float GetAngle(float x1, float y1, float x2, float y2);
float GetAngle(Vector2 a, Vector2 b);</code></pre>
                <h3>Descripción</h3>
                <p>Devuelve el ángulo que forman 2 puntos (2 sobrecargas) respecto la horizontal. El primer parámetro determina el vértice del ángulo y el segundo parámetro la apertura de ese ángulo. El resultado es devuelto en RADIANES.</p>
                <h3>Ejemplo</h3>
                <pre><code>Vector2 origin = {10.0f, 10.0f};
Vector2 destination = {100.0f, 15.0f};
float a = ngn->math->GetAngle(origin, destination);</code></pre>
            </section>
            
            <section id="GetManhattan" class="doc-block">
                <h3>Método</h3>
                <pre><code>float GetManhattan(float x1, float y1, float x2, float y2);
float GetManhattan(Vector2 a, Vector2 b);
uint32_t GetManhattan(int32_t x1, int32_t y1, int32_t x2, int32_t y2);
uint32_t GetManhattan(Vector2I32 a, Vector2I32 b);</code></pre>
                <h3>Descripción</h3>
                <p>Devuelve la distancia Manhattan entre 2 puntos (4 sobrecargas). Esta distancia es la suma de las diferencias en valor absoluto de las diferentes coordenadas (<code>abs(x1 - x2) + abs(y1 - y2)</code>).</p>
                <h3>Ejemplo</h3>
                <pre><code>float d = ngn->math->GetGetManhattan(100.0f, 100.0f, 200.0f, 300.0f);</code></pre>
            </section>
            
            <section id="Random" class="doc-block">
                <h3>Método(s)</h3>
                <pre><code>int32_t RandomInt(int32_t min_value, int32_t max_value);
int32_t RandomInt();
float RandomFloat(float min_value, float max_value);
float RandomFloat();
double RandomDouble(double min_value, double max_value);
double RandomDouble();</code></pre>
                <h3>Descripción</h3>
                <p>Devuelve un número aleatorio según el tipo del método, comprendido entre el rango especificado. Si no se especifica un rango, el número se generará entre 0 y el valor máximo del tipo correspondiente.</p>
                <h3>Ejemplo(s)</h3>
                <pre><code>int32_t a = ngn->math->RandomInt(-3, 120);
int32_t b = ngn->math->RandomInt();
float c = ngn->math->RandomFloat(100.0f, 999.9f);
float d = ngn->math->RandomFloat();
double e = ngn->math->RandomDouble(-99.99, 99.99);
double f = ngn->math->RandomDouble();</code></pre>
            </section>
            
            <section id="Adler32Checksum" class="doc-block">
                <h3>Método(s)</h3>
                <pre><code>uint32_t Adler32Checksum(const std::vector&lt;uint8_t&gt;& buffer, uint32_t start_index = 0);</code></pre>
                <h3>Descripción</h3>
                <p>Calcula y devuelve una suma de verificación (checksum) Adler-32 de 32 bits para el búfer de datos proporcionado. Opcionalmente, se permite especificar el índice a partir del cual comenzará el cálculo. Por defecto, se procesan todos los datos. El tamaño máximo de los datos a procesar está limitado por el índice de 32 bits a 4 GiB (2^32 bytes).</p>
                <h3>Ejemplo(s)</h3>
                <pre><code>uint32_t chk_save = ngn->math->Adler32Checksum(save_data);
uint32_t chk_config = ngn->math->Adler32Checksum(config_data, 64);</code></pre>
            </section>
        </main>
    </div>

	<!-- BOTONES FLOTANTES Y SCRIPT (con menú desplegable para el Manual) -->
	<div class="floating-buttons">
        <!-- Bandeja de botones que se mostrará/ocultará -->
		<div id="button-tray">
			<a href="index.html">Volver al Índice</a>
			<!-- Enlace a la página equivalente en inglés -->
			<a href="../en/ngn_math.html">English Version</a>
			<a href="#" id="back-to-top">Volver Arriba</a>
		</div>
        <!-- Botón principal que siempre es visible en móvil -->
        <button id="menu-toggle">Menú ▲</button>
	</div>

    <script>
        // Lógica para el botón "Volver Arriba"
        const backToTopButton = document.getElementById('back-to-top');
        window.onscroll = () => {
            const scrollPosition = document.documentElement.scrollTop || document.body.scrollTop;
            if (scrollPosition > 200) { backToTopButton.classList.add('visible'); } 
            else { backToTopButton.classList.remove('visible'); }
        };
        
        // --- LÓGICA PARA EL MENÚ DESPLEGABLE ---
        const menuToggle = document.getElementById('menu-toggle');
        const floatingButtonsContainer = document.querySelector('.floating-buttons');
        menuToggle.addEventListener('click', () => {
            floatingButtonsContainer.classList.toggle('is-active');
        });

        floatingButtonsContainer.addEventListener('click', (e) => {
            if (e.target.id === 'back-to-top') {
                e.preventDefault();
                window.scrollTo({ top: 0, behavior: 'smooth' });
                floatingButtonsContainer.classList.remove('is-active');
            }
        });
    </script>
</body>
</html>