<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentación n'gine - NGN_LOAD</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>NGN_LOAD.H</h1>
        </header>

        <main>
            <!-- ÍNDICE DE MÉTODOS -->
            <h2>MÉTODOS de la clase</h2>
            <nav class="index">
                <ul>
                    <li><a href="#Texture">Texture</a></li>
                    <li><a href="#TiledBg">TiledBg</a></li>
                    <li><a href="#Sprite">Sprite</a></li>
                    <li><a href="#CollisionMap">CollisionMap</a></li>
                    <li><a href="#AudioClip">AudioClip</a></li>
                    <li><a href="#TrueTypeFont">TrueTypeFont</a></li>
                    <li><a href="#PngAsRaw">PngAsRaw</a></li>
                    <li><a href="#SpriteAsRaw">SpriteAsRaw</a></li>
                    <li><a href="#SpriteAsRawVector">SpriteAsRawVector</a></li>
                    <li><a href="#TextFile">TextFile</a></li>
                    <li><a href="#LoadFile">LoadFile</a></li>
                    <li><a href="#SetDisk">SetDisk</a></li>
                    <li><a href="#SetPackage">SetPackage</a></li>
                </ul>
            </nav>
            <hr>

            <!-- BLOQUES DE DOCUMENTACIÓN DE MÉTODOS -->
            <section id="Texture" class="doc-block">
                <h3>Método</h3>
                <pre><code>NGN_TextureData* Texture(std::string filepath);</code></pre>
                <h3>Descripción</h3>
                <p>Carga una imagen en formato PNG y la convierte a datos de textura. El tamaño máximo de imagen soportado es de 8192x8192 píxeles. Devuelve NULL en caso de error.</p>
                <h3>Ejemplo</h3>
                <pre><code>NGN_TextureData* bg_grid = ngn->load->Texture("data/png/grid.png");</code></pre>
            </section>

            <section id="TiledBg" class="doc-block">
                <h3>Método</h3>
                <pre><code>NGN_TiledBgData* TiledBg(std::string filepath);</code></pre>
                <h3>Descripción</h3>
                <p>Carga los datos de un fondo de tiles en formato .tbg (Ver las utilidades adjuntas de la librería). El tamaño máximo del tileset es de 8192x8192 píxeles. Devuelve NULL en caso de error.</p>
                <h3>Ejemplo</h3>
                <pre><code>NGN_TiledBgData* tiles_bg_front = ngn->load->TiledBg("data/bg/bg_front.tbg");</code></pre>
            </section>

            <section id="Sprite" class="doc-block">
                <h3>Método</h3>
                <pre><code>NGN_SpriteData* Sprite(std::string filepath);</code></pre>
                <h3>Descripción</h3>
                <p>Carga los datos de un sprite en formato .spr (Ver las utilidades adjuntas de la librería). El tamaño máximo de cada fotograma del sprite es de 8192x8192 píxeles. Devuelve NULL en caso de error.</p>
                <h3>Ejemplo</h3>
                <pre><code>NGN_SpriteData*  wizard_sprite = ngn->load->Sprite("data/spr/wizard.spr");</code></pre>
            </section>

            <section id="CollisionMap" class="doc-block">
                <h3>Método</h3>
                <pre><code>NGN_CollisionMapData* CollisionMap(std::string filepath);</code></pre>
                <h3>Descripción</h3>
                <p>Carga los datos de un mapa de colisiones en formato .map (Ver las utilidades adjuntas de la librería). Devuelve NULL en caso de error.</p>
                <h3>Ejemplo</h3>
                <pre><code>NGN_CollisionMapData* collision_map = ngn->load->CollisionMap("data/collision/mainmap.map");</code></pre>
            </section>

            <section id="AudioClip" class="doc-block">
                <h3>Método</h3>
                <pre><code>NGN_AudioClipData* AudioClip(std::string filepath);</code></pre>
                <h3>Descripción</h3>
                <p>Carga un archivo de audio en formato WAV, FLAC o OGG y lo convierte al formato AudioClipData para usarlo como efecto de sonido. Devuelve NULL en caso de error.</p>
                <h3>Ejemplo</h3>
                <pre><code>NGN_AudioClipData* coin_sfx = ngn->load->AudioClip("data/wav/coin.wav");</code></pre>
            </section>

            <section id="TrueTypeFont" class="doc-block">
                <h3>Método</h3>
                <pre><code>NGN_TextFont* TrueTypeFont(
    std::string filepath,               // Archivo a cargar
    uint32_t height,                    // Altura de la fuente (en pixeles)
    bool antialias = true,              // Antialias?
    uint32_t font_color = 0xFFFFFF,     // Color base (RGB)
    uint32_t outline = 0,               // Borde? (en pixeles)
    uint32_t outline_color = 0x000000   // Color del borde (RGB)
);</code></pre>
                <h3>Descripción</h3>
                <p>Carga un archivo de fuente tipográfica TRUE TYPE y a partir de el, genera las texturas para cada caracter con el tamaño de fuente y propiedades especificadas. Devuelve NULL en caso de no poder cargar o convertir la fuente.</p>
                <h3>Ejemplo</h3>
                <pre><code>NGN_TextFont* font = ngn->load->TrueTypeFont("data/consolas.ttf", 24);</code></pre>
            </section>

            <section id="PngAsRaw" class="doc-block">
                <h3>Método</h3>
                <pre><code>NGN_RawImage* PngAsRaw(std::string filepath);</code></pre>
                <h3>Descripción</h3>
                <p>Carga una imagen en formato PNG y devuelve los pixeles de la misma en formato RAW. Devuelve NULL en caso de error.</p>
                <h3>Ejemplo</h3>
                <pre><code>NGN_RawImage* pixels = ngn->load->PngAsRaw("data/clouds.png");</code></pre>
            </section>

            <section id="SpriteAsRaw" class="doc-block">
                <h3>Método</h3>
                <pre><code>NGN_RawImage* SpriteAsRaw(
    std::string filepath,   // Archivo a cargar
    uint32_t frame = 0      // Fotograma a convertir
);</code></pre>
                <h3>Descripción</h3>
                <p>Carga los datos de un sprite y devuelve los pixeles del fotograma especificado (el primero por defecto) formato RAW. Devuelve NULL en caso de error.</p>
                <h3>Ejemplo</h3>
                <pre><code>NGN_RawImage* pixels = ngn->load->SpriteAsRaw("data/coin.spr", 3);</code></pre>
            </section>

            <section id="SpriteAsRawVector" class="doc-block">
                <h3>Método</h3>
                <pre><code>bool SpriteAsRawVector(
    std::string filepath,                       // Archivo a cargar
    std::vector&lt;NGN_RawImage*&gt; &raw_frames,  // Vector de destino con los frames
    uint32_t first_frame = 0,                   // Frame inicial (0 por defecto)
    uint32_t last_frame = NGN_DEFAULT_VALUE     // Frame final (ultimo por defecto)
);</code></pre>
                <h3>Descripción</h3>
                <p>Carga los datos de un sprite y almacena los pixeles de los fotogramas especificados (todos los fotogramas por defecto) formato RAW dentro de un vector. Devuelve TRUE en caso de éxito y FALSE en caso de error.</p>
                <h3>Ejemplo</h3>
                <pre><code>std::vector&lt;NGN_RawImage*&gt; frames;
ngn->load->SpriteAsRawVector("data/coin.spr", frames, 2, 5);</code></pre>
            </section>

            <section id="TextFile" class="doc-block">
                <h3>Método</h3>
                <pre><code>// Primera sobrecarga
std::string TextFile(std::string filepath);

// Segunda sobrecarga
std::string TextFile(
    std::string filepath,                   // Archivo
    std::vector&lt;std::string&gt; &text_lines    // Buffer de destino
);</code></pre>
                <h3>Descripción</h3>
                <p>Lee el archivo de texto de la ruta especificada y lo devuelve en un string (primera sobrecarga) o almacena las líneas de texto del archivo en el buffer dado y devuelve true o false según sí se ha tenido éxito (segunda sobrecarga).</p>
                <h3>Ejemplo</h3>
                <pre><code>// Primera sobrecarga
std::string text = ngn->load->TextFile("data/script.txt");

// Segunda sobrecarga
std::vector&lt;std::string&gt; buffer;
buffer.clear();
ngn->load->TextFile("data/script.txt", buffer);</code></pre>
            </section>

            <section id="LoadFile" class="doc-block">
                <h3>Método</h3>
                <pre><code>int32_t LoadFile(
    std::string filepath,           // Archivo
    std::vector&lt;uint8_t&gt; &data     // Vector de datos
);</code></pre>
                <h3>Descripción</h3>
                <p>Lee el archivo de la ruta especificada desde el sistema de archivos del dispositivo o desde un paquete de archivos (ver SetDisk() y SetPackage()) y coloca los datos en el vector dado. Si se lee el archivo desde un paquete y este está encriptado, se desencriptará el contenido. El método devuelve el número de bytes leídos o -1 en caso de error.</p>
                <h3>Ejemplo</h3>
                <pre><code>std::vector&lt;uint8_t&gt; buffer;
int32_t file_length = ngn->load->LoadFile("data/stage.bin", buffer);</code></pre>
            </section>

            <section id="SetDisk" class="doc-block">
                <h3>Método</h3>
                <pre><code>void SetDisk();</code></pre>
                <h3>Descripción</h3>
                <p>A partir de ese momento, establece el sistema de archivos del dispositivo como el origen de los datos en los métodos de carga.</p>
                <h3>Ejemplo</h3>
                <pre><code>ngn->load->SetDisk();</code></pre>
            </section>

            <section id="SetPackage" class="doc-block">
                <h3>Método</h3>
                <pre><code>bool SetPackage(std::string pkg_file, std::string key = "");</code></pre>
                <h3>Descripción</h3>
                <p>A partir de ese momento, establece un paquete de archivos creado con la herramienta NGN_FileSystem como el origen de los datos en los métodos de carga. Si los archivos del paquete están encriptados, deberá de proporcionarse la clave de encriptación en el segundo parámetro.</p>
                <h3>Ejemplo</h3>
                <pre><code>ngn->load->SetPackage("gamedata.pkg", "myawesomekey");</code></pre>
            </section>
        </main>
    </div>

	<!-- BOTONES FLOTANTES Y SCRIPT (con menú desplegable para el Manual) -->
	<div class="floating-buttons">
        <!-- Bandeja de botones que se mostrará/ocultará -->
		<div id="button-tray">
			<a href="index.html">Volver al Índice</a>
			<!-- Enlace a la página equivalente en inglés -->
			<a href="../en/ngn_load.html">English Version</a>
			<a href="#" id="back-to-top">Volver Arriba</a>
		</div>
        <!-- Botón principal que siempre es visible en móvil -->
        <button id="menu-toggle">Menú ▲</button>
	</div>

    <script>
        // Lógica para el botón "Volver Arriba"
        const backToTopButton = document.getElementById('back-to-top');
        window.onscroll = () => {
            const scrollPosition = document.documentElement.scrollTop || document.body.scrollTop;
            if (scrollPosition > 200) { backToTopButton.classList.add('visible'); } 
            else { backToTopButton.classList.remove('visible'); }
        };
        
        // --- LÓGICA PARA EL MENÚ DESPLEGABLE ---
        const menuToggle = document.getElementById('menu-toggle');
        const floatingButtonsContainer = document.querySelector('.floating-buttons');
        menuToggle.addEventListener('click', () => {
            floatingButtonsContainer.classList.toggle('is-active');
        });

        floatingButtonsContainer.addEventListener('click', (e) => {
            if (e.target.id === 'back-to-top') {
                e.preventDefault();
                window.scrollTo({ top: 0, behavior: 'smooth' });
                floatingButtonsContainer.classList.remove('is-active');
            }
        });
    </script>
</body>
</html>