<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>n'gine Documentation - NGN_COLLISIONS</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>NGN_COLLISIONS.H</h1>
        </header>

        <main>
            <!-- METHODS INDEX -->
            <h2>METHODS of the class</h2>
            <nav class="index">
                <ul>
                    <li><a href="#GetPixel">GetPixel</a></li>
                    <li><a href="#GetMapSize">GetMapSize</a></li>
                    <li><a href="#HitBox">HitBox</a></li>
                    <li><a href="#PixelPerfect">PixelPerfect</a></li>
                    <li><a href="#RaycastPoint">RaycastPoint</a></li>
                </ul>
            </nav>
            <hr>

            <!-- METHODS DOCUMENTATION BLOCKS -->
            <section id="GetPixel" class="doc-block">
                <h3>Method</h3>
                <pre><code>uint32_t GetPixel(
    NGN_CollisionMapData* cmap,     // Collision map data
    int32_t position_x,             // X coordinate on the map
    int32_t position_y              // Y coordinate on the map
);</code></pre>
                <h3>Description</h3>
                <p>Returns the color of the pixel from the given map at the provided coordinates. If the coordinates are outside the map, it returns 0x00000000. The format of the returned color is 0xRRGGBBAA (RGBA).</p>
                <h3>Example</h3>
                <pre><code>uint32_t color = ngn->collisions->GetPixel(
    collision_map,
    wizard.sprite->position.x,
    wizard.sprite->position.y
);</code></pre>
            </section>

            <section id="GetMapSize" class="doc-block">
                <h3>Method</h3>
                <pre><code>Size2 GetMapSize(NGN_CollisionMapData* cmap);</code></pre>
                <h3>Description</h3>
                <p>Returns the size of the given map in Size2 format (width and height).</p>
                <h3>Example</h3>
                <pre><code>Size2 world_size = ngn->collisions->GetMapSize(collision_map);</code></pre>
            </section>

            <section id="HitBox" class="doc-block">
                <h3>Method</h3>
                <pre><code>bool HitBox(NGN_Sprite* spr1, NGN_Sprite* spr2);</code></pre>
                <h3>Description</h3>
                <p>Performs a bounding box collision check between two sprites. Returns TRUE in case of collision.</p>
                <h3>Example</h3>
                <pre><code>if (ngn->collisions->HitBox(player, coin)) {
    hit = true;
} else {
    hit = false;
}</code></pre>
            </section>

            <section id="PixelPerfect" class="doc-block">
                <h3>Method</h3>
                <pre><code>bool PixelPerfect(NGN_Sprite* spr1, NGN_Sprite* spr2);</code></pre>
                <h3>Description</h3>
                <p>Performs a pixel-level collision check between two sprites. Returns TRUE in case of collision.</p>
                <h3>Example</h3>
                <pre><code>if (ngn->collisions->PixelPerfect(player, coin)) {
    hit = true;
} else {
    hit = false;
}</code></pre>
                <p><strong>Note:</strong> Pixel-level collision detection consumes a significant amount of CPU resources. Use only in cases where it is absolutely necessary.</p>
            </section>

            <section id="RaycastPoint" class="doc-block">
                <h3>Method</h3>
                <pre><code>bool RaycastPoint(
    NGN_Sprite* spr,       // Sprite
    float position_x,      // X coordinate to check
    float position_y       // Y coordinate to check
);

bool RaycastPoint(NGN_Sprite* spr, Vector2 position);</code></pre>
                <h3>Description</h3>
                <p>Checks if there is a visible pixel from the provided sprite at the given coordinates.</p>
                <h3>Example</h3>
                <pre><code>if (ngn->collisions->RaycastPoint(coin, 128, 96)) {
    hit = true;
} else {
    hit = false;
}</code></pre>
            </section>
        </main>
    </div>

	<!-- FLOATING BUTTONS AND SCRIPT (with dropdown menu for the Manual) -->
	<div class="floating-buttons">
        <!-- Button tray that will be shown/hidden -->
		<div id="button-tray">
			<a href="index.html">Back to Index</a>
			<!-- Link to the equivalent Spanish page -->
			<a href="../es/ngn_collisions.html">Versión en Español</a>
			<a href="#" id="back-to-top">Back to Top</a>
		</div>
        <!-- Main button that is always visible on mobile -->
        <button id="menu-toggle">Menu ▲</button>
	</div>

    <script>
        // Logic for the "Back to Top" button
        const backToTopButton = document.getElementById('back-to-top');
        window.onscroll = () => {
            const scrollPosition = document.documentElement.scrollTop || document.body.scrollTop;
            if (scrollPosition > 200) { backToTopButton.classList.add('visible'); }
             else { backToTopButton.classList.remove('visible'); }
        };
        
        // --- LOGIC FOR THE DROPDOWN MENU ---
        const menuToggle = document.getElementById('menu-toggle');
        const floatingButtonsContainer = document.querySelector('.floating-buttons');
        menuToggle.addEventListener('click', () => {
            floatingButtonsContainer.classList.toggle('is-active');
        });

        floatingButtonsContainer.addEventListener('click', (e) => {
            if (e.target.id === 'back-to-top') {
                e.preventDefault();
                window.scrollTo({ top: 0, behavior: 'smooth' });
                floatingButtonsContainer.classList.remove('is-active');
            }
        });
    </script>
</body>
</html>