<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>n'gine Documentation - NGN_TEXT_LAYER</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>NGN_TEXT_LAYER.H</h1>
        </header>

        <main>
            <!-- LAYER METHODS -->
            <h2>METHODS of the class: Text layer methods</h2>
            <nav class="index">
                <ul>
                    <li><a href="#Constructor">NGN_TextLayer (Constructor)</a></li>
                    <li><a href="#Position">Position</a></li>
                    <li><a href="#Translate">Translate</a></li>
                    <li><a href="#Size">Size</a></li>
                    <li><a href="#Scale">Scale</a></li>
                    <li><a href="#Rotate">Rotate</a></li>
                    <li><a href="#SetCenter">SetCenter</a></li>
                    <li><a href="#GetSize">GetSize</a></li>
                    <li><a href="#SetTintColor">SetTintColor</a></li>
					<li><a href="#GetCurrentScale">GetCurrentScale</a></li>
                </ul>
            </nav>
            <hr>
			
            <div class="doc-block">
                 <p><strong>Note:</strong> Changes in size or scale do not affect the original size of the container; they only alter the size of the content when displayed on the screen.</p>
            </div>
			<hr>

            <section id="Constructor" class="doc-block">
                <h3>Method</h3>
                <pre><code>NGN_TextLayer(
    NGN_TextFont* default_font,         // Default font
    NGN_TextureData* bg = NULL,         // Texture data for the background
    int32_t position_x = 0,             // X position (0 by default)
    int32_t position_y = 0,             // Y position (0 by default)
    uint32_t _width = DEFAULT_VALUE,    // Layer width (Whole screen by default)
    uint32_t _height = DEFAULT_VALUE,   // Layer height (Whole screen by default)
    bool _filtering = false             // Content filtering?
);</code></pre>
                <h3>Description</h3>
                <p>Creates a new text layer using the specified font and parameters. If texture data for the background is specified, the layer will be created using the size of the texture image. If a layer size is specified, it takes precedence. If NULL is used for the background parameter, it will be transparent by default. If neither background nor size is specified, the layer will cover the entire window.</p>
                <h3>Example</h3>
                <pre><code>NGN_TextLayer* allscreen = new NGN_TextLayer(my_font);
NGN_TextLayer* smalltext = new NGN_TextLayer(my_font, NULL, 100, 50, 200, 64);
NGN_TextLayer* textbox = new NGN_TextLayer(my_font, boximg, 20, 500);</code></pre>
            </section>

            <section id="Position" class="doc-block">
                <h3>Method</h3>
                <pre><code>void Position(float position_x, float position_y);
void Position(Vector2 pos);</code></pre>
                <h3>Description</h3>
                <p>Positions the text layer at the given coordinates.</p>
                <h3>Example</h3>
                <pre><code>textbox->Position(1200, 900);</code></pre>
            </section>

            <section id="Translate" class="doc-block">
                <h3>Method</h3>
                <pre><code>void Translate(float speed_x, float speed_y);
void Translate(Vector2 spd);</code></pre>
                <h3>Description</h3>
                <p>Moves the text layer in the given direction and speeds.</p>
                <h3>Example</h3>
                <pre><code>textbox->Translate(5.0f, 0.0f);</code></pre>
            </section>

            <section id="Size" class="doc-block">
                <h3>Method</h3>
                <pre><code>void Size(float w, float h);</code></pre>
                <h3>Description</h3>
                <p>Changes the size of the text layer.</p>
                <h3>Example</h3>
                <pre><code>textbox->Size(64, 48);</code></pre>
            </section>

            <section id="Scale" class="doc-block">
                <h3>Method</h3>
                <pre><code>void Scale(float w, float h);
void Scale(float scale);</code></pre>
                <h3>Description</h3>
                <p>Scales the text layer by the given factor. Depending on the overload used, it will scale the axes together or separately. The default scale is 1.0f.</p>
                <h3>Example</h3>
                <pre><code>textbox->Scale(1.5f);
textbox->Scale(2.0f, 0.75f);</code></pre>
            </section>

            <section id="Rotate" class="doc-block">
                <h3>Method</h3>
                <pre><code>void Rotate(double degrees);</code></pre>
                <h3>Description</h3>
                <p>Rotates the text layer by the provided number of degrees.</p>
                <h3>Example</h3>
                <pre><code>textbox->Rotate(1.2f);</code></pre>
            </section>
            
            <section id="SetCenter" class="doc-block">
                <h3>Method</h3>
                <pre><code>void SetCenter(float x, float y);</code></pre>
                <h3>Description</h3>
                <p>Specifies, in relative coordinates from the actual center of the text layer, where the rotation center of the text layer will be located.</p>
                <h3>Example</h3>
                <pre><code>textbox->SetCenter(-10, -5);</code></pre>
            </section>
            
            <section id="GetSize" class="doc-block">
                <h3>Method</h3>
                <pre><code>Size2I32 GetSize();</code></pre>
                <h3>Description</h3>
                <p>Returns the original size of the text layer.</p>
                <h3>Example</h3>
                <pre><code>Size2I32 s = textbox->GetSize();</code></pre>
            </section>

            <section id="SetTintColor" class="doc-block">
                <h3>Method</h3>
                <pre><code>void SetTintColor(uint8_t r = 0xFF, uint8_t g = 0xFF, uint8_t b = 0xFF);</code></pre>
                <h3>Description</h3>
                <p>Sets a tint color that will be applied to the text layer. A white tint (255, 255, 255) will display the text layer with its original unaltered colors.</p>
                <h3>Example</h3>
                <pre><code>textbox->SetTintColor(96, 255, 192);</code></pre>
            </section>
			
            <section id="GetCurrentScale" class="doc-block">
                <h3>Method</h3>
                <pre><code>Size2 GetCurrentScale();</code></pre>
                <h3>Description</h3>
                <p>Returns a Size2 structure containing the current scale of the text layer.</p>
                <h3>Example</h3>
                <pre><code>Size2 current_scale = textbox->GetCurrentScale();</code></pre>
            </section>
			
            <hr>

            <!-- LAYER PROPERTIES -->
            <h2>PROPERTIES of the class: Text layer properties</h2>
            <nav class="index">
                <ul>
                    <li><a href="#prop_position">position / screen</a></li>
                    <li><a href="#prop_size">width / height</a></li>
                    <li><a href="#prop_visible">visible</a></li>
                    <li><a href="#prop_alpha">alpha</a></li>
                    <li><a href="#prop_blend_mode">blend_mode</a></li>
                    <li><a href="#prop_filtering">filtering</a></li>
                    <li><a href="#prop_rotation">rotation</a></li>
                    <li><a href="#prop_flip">flip_h / flip_v</a></li>
                </ul>
            </nav>
			<hr>
            
            <section id="prop_position" class="doc-block">
                <h3>Property</h3>
                <pre><code>Vector2 position</code></pre>
                <h3>Description</h3>
                <p>Position of the text layer on the screen.</p>
            </section>

            <section id="prop_size" class="doc-block">
                <h3>Property</h3>
                <pre><code>float width
float height</code></pre>
                <h3>Description</h3>
                <p>Size of the text layer.</p>
            </section>

            <section id="prop_visible" class="doc-block">
                <h3>Property</h3>
                <pre><code>bool visible</code></pre>
                <h3>Description</h3>
                <p>Indicates whether the text layer is visible or not.</p>
            </section>

            <section id="prop_alpha" class="doc-block">
                <h3>Property</h3>
                <pre><code>int32_t alpha</code></pre>
                <h3>Description</h3>
                <p>Text layer transparency level, ranging from 0 to 255.</p>
            </section>

            <section id="prop_blend_mode" class="doc-block">
                <h3>Property</h3>
                <pre><code>SDL_BlendMode blend_mode</code></pre>
                <h3>Description</h3>
                <p>Text layer color blend mode. Available modes are: <code>NGN_BLENDMODE_NONE</code>, <code>NGN_BLENDMODE_ALPHA</code>, <code>NGN_BLENDMODE_ADDITIVE</code> and <code>NGN_BLENDMODE_MODULATE</code>. The default value for this property is <code>NGN_BLENDMODE_ALPHA</code>.</p>
            </section>

            <section id="prop_filtering" class="doc-block">
                <h3>Property</h3>
                <pre><code>bool filtering</code></pre>
                <h3>Description</h3>
                <p>Enables or disables bilinear filtering for the content of the text layer.</p>
            </section>
            
            <section id="prop_rotation" class="doc-block">
                <h3>Property</h3>
                <pre><code>double rotation</code></pre>
                <h3>Description</h3>
                <p>Text layer rotation, in degrees.</p>
            </section>

            <section id="prop_flip" class="doc-block">
                <h3>Property</h3>
                <pre><code>bool flip_h
bool flip_v</code></pre>
                <h3>Description</h3>
                <p>Horizontal and vertical flipping of the text layer.</p>
            </section>
            <hr>

            <!-- WRITING METHODS -->
            <h2>METHODS of the class: Text writing methods</h2>
            <nav class="index">
                <ul>
                    <li><a href="#Cls">Cls</a></li>
                    <li><a href="#Locate">Locate</a></li>
                    <li><a href="#Padding">Padding</a></li>
                    <li><a href="#Font">Font</a></li>
                    <li><a href="#InkColor">InkColor</a></li>
                    <li><a href="#CanvasColor">CanvasColor</a></li>
                    <li><a href="#Print">Print</a></li>
                </ul>
            </nav>
            <hr>

            <section id="Cls" class="doc-block">
                <h3>Method</h3>
                <pre><code>void Cls();</code></pre>
                <h3>Description</h3>
                <p>Clears the content of the text layer and resets the writing cursor position to the top-left corner. If there is no specific background texture, the layer will be filled with the background color specified in the <code>CanvasColor()</code> method.</p>
                <h3>Example</h3>
                <pre><code>textbox->Cls();</code></pre>
            </section>

            <section id="Locate" class="doc-block">
                <h3>Method</h3>
                <pre><code>void Locate(int32_t x, int32_t y);</code></pre>
                <h3>Description</h3>
                <p>Positions the writing cursor at the specified local coordinates of the layer.</p>
                <h3>Example</h3>
                <pre><code>textbox->Locate(100, 50);</code></pre>
            </section>
            
            <section id="Padding" class="doc-block">
                <h3>Method</h3>
                <pre><code>void Padding(uint32_t pd);</code></pre>
                <h3>Description</h3>
                <p>Defines the inner margin that the text layer will have from that moment on.</p>
                <h3>Example</h3>
                <pre><code>textbox->Padding(16);</code></pre>
            </section>

            <section id="Font" class="doc-block">
                <h3>Method</h3>
                <pre><code>void Font(NGN_TextFont* fnt);</code></pre>
                <h3>Description</h3>
                <p>Selects the font to be used in text writing from that moment on.</p>
                <h3>Example</h3>
                <pre><code>textbox->Font(my_font);</code></pre>
            </section>

            <section id="InkColor" class="doc-block">
                <h3>Method</h3>
                <pre><code>void InkColor(uint8_t r, uint8_t g, uint8_t b);  // [R, G, B]
void InkColor(uint32_t rgb);                     // [0xRRGGBB]</code></pre>
                <h3>Description</h3>
                <p>Selects the color to be used for text from that moment on.</p>
                <h3>Example</h3>
                <pre><code>textbox->InkColor(255, 200, 40);
textbox->InkColor(0xFFAA33);</code></pre>
            </section>
            
            <section id="CanvasColor" class="doc-block">
                <h3>Method</h3>
                <pre><code>void CanvasColor(uint8_t r, uint8_t g, uint8_t b, uint8_t a);  // [R, G, B, A]
void CanvasColor(uint32_t rgba);                                // [0xRRGGBBAA];</code></pre>
                <h3>Description</h3>
                <p>Selects the color to be used for the background of the text layer from the next erase with the <code>Cls()</code> method, in case a texture is not defined for the background.</p>
                <h3>Example</h3>
                <pre><code>textbox->CanvasColor(0, 0, 0, 128);
textbox->CanvasColor(0xFF0000FF);</code></pre>
            </section>
            
            <section id="Print" class="doc-block">
                <h3>Method</h3>
                <pre><code>void Print(std::string text);</code></pre>
                <h3>Description</h3>
                <p>Writes the given text from the current writing cursor position, using the defined color. The "\n" character will be recognized as a line break.</p>
                <h3>Example</h3>
                <pre><code>textbox->Print(“Hello World!”);</code></pre>
            </section>
            <hr>

            <!-- WRITING PROPERTIES -->
            <h2>PROPERTIES of the class: Text writing properties</h2>
            <nav class="index">
                <ul>
                    <li><a href="#prop_locate">locate</a></li>
                    <li><a href="#prop_ink">ink</a></li>
                    <li><a href="#prop_canvas">canvas</a></li>
                    <li><a href="#prop_text_boundaries">text_boundaries</a></li>
                    <li><a href="#prop_padding">padding</a></li>
                    <li><a href="#prop_word_wrap">word_wrap</a></li>
                    <li><a href="#prop_auto_home">auto_home</a></li>
                </ul>
            </nav>
			<hr>
            
            <section id="prop_locate" class="doc-block">
                <h3>Property</h3>
                <pre><code>Vector2I32 locate</code></pre>
                <h3>Description</h3>
                <p>Current position of the writing cursor in the text layer.</p>
            </section>
            
            <section id="prop_ink" class="doc-block">
                <h3>Property</h3>
                <pre><code>struct {
    uint8_t r;
    uint8_t g;
    uint8_t b;
} ink;</code></pre>
                <h3>Description</h3>
                <p>Current color for the text.</p>
            </section>

            <section id="prop_canvas" class="doc-block">
                <h3>Property</h3>
                <pre><code>struct {
    uint8_t r;
    uint8_t g;
    uint8_t b;
    uint8_t a;
} canvas;</code></pre>
                <h3>Description</h3>
                <p>Current color of the background for the text layer.</p>
            </section>
            
            <section id="prop_text_boundaries" class="doc-block">
                <h3>Property</h3>
                <pre><code>struct {
    int32_t top;
    int32_t bottom;
    int32_t left;
    int32_t right;
    int32_t width;
    int32_t height;
} text_boundaries;</code></pre>
                <h3>Description</h3>
                <p>Current boundaries of the content in the text layer.</p>
            </section>

            <section id="prop_padding" class="doc-block">
                <h3>Property</h3>
                <pre><code>int32_t padding</code></pre>
                <h3>Description</h3>
                <p>Current inner margin of the text layer.</p>
            </section>

            <section id="prop_word_wrap" class="doc-block">
                <h3>Property</h3>
                <pre><code>bool word_wrap</code></pre>
                <h3>Description</h3>
                <p>Automatic line break when reaching the layer limit (enabled by default).</p>
            </section>
            
            <section id="prop_auto_home" class="doc-block">
                <h3>Property</h3>
                <pre><code>bool auto_home</code></pre>
                <h3>Description</h3>
                <p>Automatic reset of the writing cursor position when reaching the end of the text layer (disabled by default).</p>
            </section>
        </main>
    </div>

	<!-- FLOATING BUTTONS AND SCRIPT (with dropdown menu for the Manual) -->
	<div class="floating-buttons">
        <!-- Button tray that will be shown/hidden -->
		<div id="button-tray">
			<a href="index.html">Back to Index</a>
			<!-- Link to the equivalent Spanish page -->
			<a href="../es/ngn_text_layer.html">Versión en Español</a>
			<a href="#" id="back-to-top">Back to Top</a>
		</div>
        <!-- Main button that is always visible on mobile -->
        <button id="menu-toggle">Menu ▲</button>
	</div>

    <script>
        // Logic for the "Back to Top" button
        const backToTopButton = document.getElementById('back-to-top');
        window.onscroll = () => {
            const scrollPosition = document.documentElement.scrollTop || document.body.scrollTop;
            if (scrollPosition > 200) { backToTopButton.classList.add('visible'); }
             else { backToTopButton.classList.remove('visible'); }
        };
        
        // --- LOGIC FOR THE DROPDOWN MENU ---
        const menuToggle = document.getElementById('menu-toggle');
        const floatingButtonsContainer = document.querySelector('.floating-buttons');
        menuToggle.addEventListener('click', () => {
            floatingButtonsContainer.classList.toggle('is-active');
        });

        floatingButtonsContainer.addEventListener('click', (e) => {
            if (e.target.id === 'back-to-top') {
                e.preventDefault();
                window.scrollTo({ top: 0, behavior: 'smooth' });
                floatingButtonsContainer.classList.remove('is-active');
            }
        });
    </script>
</body>
</html>